8a9,10
>  * 8.   Modify the clEnqueWrite/ReadBuffer API to support events, a few other API functions
>  *      are added.
83d84
< 
359,360c360,367
< 	//tmpEnqueueWriteBuffer.event_wait_list = event_wait_list;
< 	//tmpEnqueueWriteBuffer.event = event;
---
> 	if (event == NULL)
> 	{
> 		tmpEnqueueWriteBuffer.event_null_flag = 1;
> 	}
> 	else
> 	{
> 		tmpEnqueueWriteBuffer.event_null_flag = 0;
> 	}
365a373,378
> 	if (num_events_in_wait_list > 0)
> 	{
> 		MPI_Send((void *)event_wait_list, sizeof(cl_event) * num_events_in_wait_list, MPI_BYTE, 0,
> 				 ENQUEUE_WRITE_BUFFER2, slaveComm);
> 	}
> 
502,503c515,522
< 	//tmpEnqueueReadBuffer.event_wait_list;
< 	//tmpEnqueueReadBuffer.event = event;
---
> 	if (event == NULL)
> 	{
> 		tmpEnqueueReadBuffer.event_null_flag = 1;
> 	}
> 	else
> 	{
> 		tmpEnqueueReadBuffer.event_null_flag = 0;
> 	}
507a527,532
> 	if (num_events_in_wait_list > 0)
> 	{
> 		MPI_Send((void *)event_wait_list, sizeof(cl_event) * num_events_in_wait_list, MPI_BYTE, 0,
> 				 ENQUEUE_READ_BUFFER1, slaveComm);
> 	}
> 
510a536,540
> 
> 	if (event != NULL)
> 	{
> 		*event = tmpEnqueueReadBuffer.event;
> 	}
724a755
> //22
762a794
> //23
799a832,1334
> 
> //24
> cl_int
> clFlush(cl_command_queue hInCmdQueue)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 	
> 	struct strFlush tmpFlush;
> 	tmpFlush.command_queue = hInCmdQueue;
> 	MPI_Send(&tmpFlush, sizeof(tmpFlush), MPI_BYTE, 0,
> 			 FLUSH_FUNC, slaveComm);
> 	MPI_Recv(&tmpFlush, sizeof(tmpFlush), MPI_BYTE, 0,
> 			 FLUSH_FUNC, slaveComm, &status);
> 	return tmpFlush.res;
> }
> 
> //25
> cl_int
> clWaitForEvents(cl_uint           num_events,
> 				const cl_event   *event_list)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 	
> 	struct strWaitForEvents tmpWaitForEvents;
> 	tmpWaitForEvents.num_events = num_events;
> 	MPI_Send(&tmpWaitForEvents, sizeof(tmpWaitForEvents), MPI_BYTE, 0,
> 			 WAIT_FOR_EVENT_FUNC, slaveComm);
> 	MPI_Recv(&tmpWaitForEvents, sizeof(tmpWaitForEvents), MPI_BYTE, 0,
> 			 WAIT_FOR_EVENT_FUNC, slaveComm, &status);
> 	return tmpWaitForEvents.res;
> }
> 
> //26
> cl_sampler
> clCreateSampler(cl_context          context,
> 				cl_bool             normalized_coords,
> 				cl_addressing_mode  addressing_mode,
> 				cl_filter_mode      filter_mode,
> 				cl_int 			   *errcode_ret)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 	
> 	struct strCreateSampler tmpCreateSampler;
> 	tmpCreateSampler.context = context;
> 	tmpCreateSampler.normalized_coords = normalized_coords;
> 	tmpCreateSampler.addressing_mode = addressing_mode;
> 	tmpCreateSampler.filter_mode = filter_mode;
> 	tmpCreateSampler.errcode_ret = 0;
> 	if (errcode_ret != NULL)
> 	{
> 		tmpCreateSampler.errcode_ret = 1;
> 	}
> 
> 	MPI_Send(&tmpCreateSampler, sizeof(tmpCreateSampler), MPI_BYTE, 0,
> 			 CREATE_SAMPLER_FUNC, slaveComm);
> 	MPI_Recv(&tmpCreateSampler, sizeof(tmpCreateSampler), MPI_BYTE, 0,
> 			 CREATE_SAMPLER_FUNC, slaveComm, &status);
> 	
> 	if (errcode_ret != NULL)
> 	{
> 		*errcode_ret = tmpCreateSampler.errcode_ret;
> 	}
> 
> 	return tmpCreateSampler.sampler;
> }
> 
> //27
> cl_int
> clGetCommandQueueInfo(cl_command_queue       command_queue,
>                       cl_command_queue_info  param_name, 
>                       size_t                 param_value_size, 
>                       void *                 param_value,
>                       size_t *               param_value_size_ret)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 	struct strGetCommandQueueInfo tmpGetCommandQueueInfo;
> 	tmpGetCommandQueueInfo.command_queue = command_queue;
> 	tmpGetCommandQueueInfo.param_name = param_name;
> 	tmpGetCommandQueueInfo.param_value_size = param_value_size;
> 	tmpGetCommandQueueInfo.param_value = param_value;
> 	tmpGetCommandQueueInfo.param_value_size_ret = 1;
> 	if (param_value_size_ret == NULL)
> 	{
> 		tmpGetCommandQueueInfo.param_value_size_ret = 0;
> 	}
> 
> 	MPI_Send(&tmpGetCommandQueueInfo, sizeof(tmpGetCommandQueueInfo), MPI_BYTE, 0,
> 			 GET_COMMAND_QUEUE_INFO_FUNC, slaveComm);
> 	MPI_Recv(&tmpGetCommandQueueInfo, sizeof(tmpGetCommandQueueInfo), MPI_BYTE, 0,
> 			 GET_COMMAND_QUEUE_INFO_FUNC, slaveComm, &status);
> 
> 	if (param_value != NULL)
> 	{
> 		MPI_Recv(param_value, param_value_size, MPI_BYTE, 0,
> 				 GET_COMMAND_QUEUE_INFO_FUNC1, slaveComm, &status);
> 	}
> 
> 	if (param_value_size_ret != NULL)
> 	{
> 		*param_value_size_ret = tmpGetCommandQueueInfo.param_value_size_ret;
> 	}
> 
> 	return tmpGetCommandQueueInfo.res;
> }
> 
> //28
> void *
> clEnqueueMapBuffer(cl_command_queue command_queue,
>                    cl_mem           buffer,
>                    cl_bool          blocking_map, 
>                    cl_map_flags     map_flags,
>                    size_t           offset,
>                    size_t           cb,
>                    cl_uint          num_events_in_wait_list,
>                    const cl_event * event_wait_list,
>                    cl_event *       event,
>                    cl_int *         errcode_ret)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 	struct strEnqueueMapBuffer tmpEnqueueMapBuffer;
> 	tmpEnqueueMapBuffer.command_queue = command_queue;
> 	tmpEnqueueMapBuffer.buffer = buffer;
> 	tmpEnqueueMapBuffer.blocking_map = blocking_map;
> 	tmpEnqueueMapBuffer.map_flags = map_flags;
> 	tmpEnqueueMapBuffer.offset = offset;
> 	tmpEnqueueMapBuffer.cb = cb;
> 	tmpEnqueueMapBuffer.num_events_in_wait_list = num_events_in_wait_list;
> 	if (event == NULL)
> 	{
> 		tmpEnqueueMapBuffer.event_null_flag = 1;
> 	}
> 	else
> 	{ 
> 		tmpEnqueueMapBuffer.event_null_flag = 0;
> 	}
> 
> 	//0, NOT NULL, 1: NULL
> 	tmpEnqueueMapBuffer.errcode_ret = 0;
> 	if (errcode_ret == NULL)
> 	{
> 		tmpEnqueueMapBuffer.errcode_ret = 1;
> 	}
> 	MPI_Send(&tmpEnqueueMapBuffer, sizeof(tmpEnqueueMapBuffer), MPI_BYTE, 0,
> 			 ENQUEUE_MAP_BUFF_FUNC, slaveComm);
> 	if (num_events_in_wait_list > 0)
> 	{
> 		MPI_Send((void *)event_wait_list, sizeof(cl_event) * num_events_in_wait_list, MPI_BYTE, 0,
> 				 ENQUEUE_MAP_BUFF_FUNC1, slaveComm);
> 	}
> 	MPI_Recv(&tmpEnqueueMapBuffer, sizeof(tmpEnqueueMapBuffer), MPI_BYTE, 0,
> 			 ENQUEUE_MAP_BUFF_FUNC, slaveComm, &status);
> 	if (event != NULL)
> 	{
> 		*event = tmpEnqueueMapBuffer.event;
> 	}
> 
> 	if (errcode_ret != NULL)
> 	{
> 		*errcode_ret = tmpEnqueueMapBuffer.errcode_ret;
> 	}
> 
> 	return tmpEnqueueMapBuffer.ret_ptr;
> }
> 
> //29
> cl_int
> clReleaseEvent(cl_event event)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 	struct strReleaseEvent tmpReleaseEvent;
> 	tmpReleaseEvent.event = event;
> 	MPI_Send(&tmpReleaseEvent, sizeof(tmpReleaseEvent), MPI_BYTE, 0,
> 			 RELEASE_EVENT_FUNC, slaveComm);
> 	MPI_Recv(&tmpReleaseEvent, sizeof(tmpReleaseEvent), MPI_BYTE, 0,
> 			 RELEASE_EVENT_FUNC, slaveComm, &status);
> 	return tmpReleaseEvent.res;
> }
> 
> //30
> cl_int
> clGetEventProfilingInfo(cl_event           event,
>                         cl_profiling_info  param_name, 
>                         size_t             param_value_size, 
>                         void *             param_value,
>                         size_t *           param_value_size_ret)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 	struct strGetEventProfilingInfo tmpGetEventProfilingInfo;
> 	tmpGetEventProfilingInfo.event = event;
> 	tmpGetEventProfilingInfo.param_name = param_name;
> 	tmpGetEventProfilingInfo.param_value_size = param_value_size;
> 	tmpGetEventProfilingInfo.param_value = param_value;
> 	tmpGetEventProfilingInfo.param_value_size_ret = 1;
> 	if (param_value_size_ret == NULL)
> 	{
> 		tmpGetEventProfilingInfo.param_value_size_ret = 0;
> 	}
> 
> 	MPI_Send(&tmpGetEventProfilingInfo, sizeof(tmpGetEventProfilingInfo), MPI_BYTE, 0,
> 			 GET_EVENT_PROF_INFO_FUNC, slaveComm);
> 	MPI_Recv(&tmpGetEventProfilingInfo, sizeof(tmpGetEventProfilingInfo), MPI_BYTE, 0,
> 			 GET_EVENT_PROF_INFO_FUNC, slaveComm, &status);
> 
> 	if (param_value != NULL)
> 	{
> 		MPI_Recv(param_value, param_value_size, MPI_BYTE, 0,
> 				 GET_EVENT_PROF_INFO_FUNC1, slaveComm, &status);
> 	}
> 
> 	if (param_value_size_ret != NULL)
> 	{
> 		*param_value_size_ret = tmpGetEventProfilingInfo.param_value_size_ret;
> 	}
> 
> 	return tmpGetEventProfilingInfo.res;
> }
> 
> //31
> cl_int
> clReleaseSampler(cl_sampler sampler)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 	struct strReleaseSampler tmpReleaseSampler;
> 	tmpReleaseSampler.sampler = sampler;
> 	MPI_Send(&tmpReleaseSampler, sizeof(tmpReleaseSampler), MPI_BYTE, 0,
> 			 RELEASE_SAMPLER_FUNC, slaveComm);
> 	MPI_Recv(&tmpReleaseSampler, sizeof(tmpReleaseSampler), MPI_BYTE, 0,
> 			 RELEASE_SAMPLER_FUNC, slaveComm, &status);
> 	return tmpReleaseSampler.res;
> }
> 
> //32
> cl_int
> clGetKernelWorkGroupInfo(cl_kernel                  kernel,
>                          cl_device_id               device,
> 						 cl_kernel_work_group_info  param_name,
> 						 size_t                     param_value_size,
> 						 void *                     param_value,
> 						 size_t *                   param_value_size_ret)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 	struct strGetKernelWorkGroupInfo tmpGetKernelWorkGroupInfo;
> 	tmpGetKernelWorkGroupInfo.kernel = kernel;
> 	tmpGetKernelWorkGroupInfo.device = device;
> 	tmpGetKernelWorkGroupInfo.param_name = param_name;
> 	tmpGetKernelWorkGroupInfo.param_value_size = param_value_size;
> 	tmpGetKernelWorkGroupInfo.param_value = param_value;
> 	tmpGetKernelWorkGroupInfo.param_value_size_ret = 1;
> 	if (param_value_size_ret == NULL)
> 	{
> 		tmpGetKernelWorkGroupInfo.param_value_size_ret = 0;
> 	}
> 
> 	MPI_Send(&tmpGetKernelWorkGroupInfo, sizeof(tmpGetKernelWorkGroupInfo), MPI_BYTE, 0,
> 			 GET_KERNEL_WGP_INFO_FUNC, slaveComm);
> 	MPI_Recv(&tmpGetKernelWorkGroupInfo, sizeof(tmpGetKernelWorkGroupInfo), MPI_BYTE, 0,
> 			 GET_KERNEL_WGP_INFO_FUNC, slaveComm, &status);
> 
> 	if (param_value != NULL)
> 	{
> 		MPI_Recv(param_value, param_value_size, MPI_BYTE, 0,
> 				 GET_KERNEL_WGP_INFO_FUNC1, slaveComm, &status);
> 	}
> 
> 	if (param_value_size_ret != NULL)
> 	{
> 		*param_value_size_ret = tmpGetKernelWorkGroupInfo.param_value_size_ret;
> 	}
> 
> 	return tmpGetKernelWorkGroupInfo.res;
> }
> 
> //33
> cl_mem
> clCreateImage2D(cl_context              context,
>                 cl_mem_flags            flags,                                
>                 const cl_image_format * image_format,                                             
>                 size_t                  image_width,                                                              
>                 size_t                  image_height,
>                 size_t                  image_row_pitch,
>                 void *                  host_ptr, 
> 				cl_int *                errcode_ret)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 	struct strCreateImage2D tmpCreateImage2D;
> 	tmpCreateImage2D.context = context;
> 	tmpCreateImage2D.flags   = flags;
> 	tmpCreateImage2D.img_format.image_channel_order = image_format->image_channel_order;
> 	tmpCreateImage2D.img_format.image_channel_data_type = image_format->image_channel_data_type;
> 	tmpCreateImage2D.image_width = image_width;
> 	tmpCreateImage2D.image_height = image_height;
> 	tmpCreateImage2D.image_row_pitch = image_row_pitch;
> 	tmpCreateImage2D.host_buff_size = 0;
> 	if (host_ptr != NULL)
> 	{
> 		if (image_row_pitch == 0)
> 		{
> 			tmpCreateImage2D.host_buff_size = image_width * sizeof(cl_image_format);
> 		}
> 		else
> 		{
> 			tmpCreateImage2D.host_buff_size = image_row_pitch;
> 		}
> 	}
> 	//default errcode 
> 	tmpCreateImage2D.errcode_ret = 0;
> 	if (errcode_ret == NULL)
> 	{
> 		tmpCreateImage2D.errcode_ret = 1;
> 	}
> 	MPI_Send(&tmpCreateImage2D, sizeof(tmpCreateImage2D), MPI_BYTE, 0,
> 			 CREATE_IMAGE_2D_FUNC, slaveComm);
> 	if (host_ptr != NULL)
> 	{
> 		MPI_Send(host_ptr, tmpCreateImage2D.host_buff_size, MPI_BYTE, 0,
> 				 CREATE_IMAGE_2D_FUNC1, slaveComm);
> 	}
> 	MPI_Recv(&tmpCreateImage2D, sizeof(tmpCreateImage2D), MPI_BYTE, 0,
> 			 CREATE_IMAGE_2D_FUNC, slaveComm, &status);
> 	if (errcode_ret != NULL)
> 	{
> 		*errcode_ret = tmpCreateImage2D.errcode_ret;
> 	}
> 
> 	return tmpCreateImage2D.mem_obj;
> }
> 
> //34
> cl_int
> clEnqueueCopyBuffer(cl_command_queue    command_queue,
>                     cl_mem              src_buffer,                                       
>                     cl_mem              dst_buffer,                                                           
>                     size_t              src_offset,                                                                               
>                     size_t              dst_offset,
>                     size_t              cb, 
>                     cl_uint             num_events_in_wait_list,
>                     const cl_event *    event_wait_list,
>                     cl_event *          event)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 
> 	struct strEnqueueCopyBuffer tmpEnqueueCopyBuffer;
> 	tmpEnqueueCopyBuffer.command_queue = command_queue;
> 	tmpEnqueueCopyBuffer.src_buffer = src_buffer;
> 	tmpEnqueueCopyBuffer.dst_buffer = dst_buffer;
> 	tmpEnqueueCopyBuffer.src_offset = src_offset;
> 	tmpEnqueueCopyBuffer.dst_offset = dst_offset;
> 	tmpEnqueueCopyBuffer.cb = cb;
> 	tmpEnqueueCopyBuffer.num_events_in_wait_list = num_events_in_wait_list;
> 	tmpEnqueueCopyBuffer.event_null_flag = 0;
> 	if (event == NULL)
> 	{
> 		tmpEnqueueCopyBuffer.event_null_flag = 1;
> 	}
> 
> 	MPI_Send(&tmpEnqueueCopyBuffer, sizeof(tmpEnqueueCopyBuffer), MPI_BYTE, 0,
> 			 ENQ_COPY_BUFF_FUNC, slaveComm);
> 	if (num_events_in_wait_list > 0)
> 	{
> 		MPI_Send((void *)event_wait_list, sizeof(cl_event) * num_events_in_wait_list, MPI_BYTE, 0,
> 				 ENQ_COPY_BUFF_FUNC1, slaveComm);
> 	}
> 	MPI_Recv(&tmpEnqueueCopyBuffer, sizeof(tmpEnqueueCopyBuffer), MPI_BYTE, 0,
> 			 ENQ_COPY_BUFF_FUNC, slaveComm, &status);
> 
> 	if (event != NULL)
> 	{
> 		*event = tmpEnqueueCopyBuffer.event;
> 	}
> 	
> 	return tmpEnqueueCopyBuffer.res;
> }
> 
> //35
> cl_int
> clRetainEvent(cl_event event)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 
> 	struct strRetainEvent tmpRetainEvent;
> 	tmpRetainEvent.event = event;
> 	MPI_Send(&tmpRetainEvent, sizeof(tmpRetainEvent), MPI_BYTE, 0,
> 			 RETAIN_EVENT_FUNC, slaveComm);
> 	MPI_Recv(&tmpRetainEvent, sizeof(tmpRetainEvent), MPI_BYTE, 0,
> 			 RETAIN_EVENT_FUNC, slaveComm, &status);
> 	return tmpRetainEvent.res;
> }
> 
> //36
> cl_int
> clRetainMemObject(cl_mem memobj)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 
> 	struct strRetainMemObject tmpRetainMemObject;
> 	tmpRetainMemObject.memobj = memobj;
> 	MPI_Send(&tmpRetainMemObject, sizeof(tmpRetainMemObject), MPI_BYTE, 0,
> 			 RETAIN_MEMOBJ_FUNC, slaveComm);
> 	MPI_Recv(&tmpRetainMemObject, sizeof(tmpRetainMemObject), MPI_BYTE, 0,
> 			 RETAIN_MEMOBJ_FUNC, slaveComm, &status);
> 	return tmpRetainMemObject.res;
> }
> 
> //37
> cl_int
> clRetainKernel(cl_kernel kernel)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 
> 	struct strRetainKernel tmpRetainKernel;
> 	tmpRetainKernel.kernel = kernel;
> 	MPI_Send(&tmpRetainKernel, sizeof(tmpRetainKernel), MPI_BYTE, 0,
> 			 RETAIN_KERNEL_FUNC, slaveComm);
> 	MPI_Recv(&tmpRetainKernel, sizeof(tmpRetainKernel), MPI_BYTE, 0,
> 			 RETAIN_KERNEL_FUNC, slaveComm, &status);
> 	return tmpRetainKernel.res;
> }
> 
> //38
> cl_int
> clRetainCommandQueue(cl_command_queue command_queue)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 
> 	struct strRetainCommandQueue tmpRetainCommandQueue;
> 	tmpRetainCommandQueue.command_queue = command_queue;
> 	MPI_Send(&tmpRetainCommandQueue, sizeof(tmpRetainCommandQueue), MPI_BYTE, 0,
> 			 RETAIN_CMDQUE_FUNC, slaveComm);
> 	MPI_Recv(&tmpRetainCommandQueue, sizeof(tmpRetainCommandQueue), MPI_BYTE, 0,
> 			 RETAIN_CMDQUE_FUNC, slaveComm, &status);
> 	return tmpRetainCommandQueue.res;
> }
> 
> //39
> cl_int
> clEnqueueUnmapMemObject(cl_command_queue command_queue,
>                         cl_mem           memobj,
>                         void *           mapped_ptr,
>                         cl_uint          num_events_in_wait_list,
>                         const cl_event * event_wait_list,
> 						cl_event *       event)
> {
> 	MPI_Status status;
> 	//check whether the slave process is created. If not, create one.
> 	checkSlaveProc();
> 	
> 	struct strEnqueueUnmapMemObject tmpEnqueueUnmapMemObject;
> 	tmpEnqueueUnmapMemObject.command_queue = command_queue;
> 	tmpEnqueueUnmapMemObject.memobj = memobj;
> 	tmpEnqueueUnmapMemObject.mapped_ptr = mapped_ptr;
> 	tmpEnqueueUnmapMemObject.num_events_in_wait_list = num_events_in_wait_list;
> 	tmpEnqueueUnmapMemObject.event_null_flag = 0;
> 	if (event == NULL)
> 	{
> 		tmpEnqueueUnmapMemObject.event_null_flag = 1;
> 	}
> 	MPI_Send(&tmpEnqueueUnmapMemObject, sizeof(tmpEnqueueUnmapMemObject), MPI_BYTE, 0,
> 			 ENQ_UNMAP_MEMOBJ_FUNC, slaveComm);
> 	if (num_events_in_wait_list > 0)
> 	{
> 		MPI_Send((void *)event_wait_list, sizeof(cl_event) * num_events_in_wait_list, MPI_BYTE, 0,
> 				 ENQ_UNMAP_MEMOBJ_FUNC1, slaveComm);
> 	}
> 	MPI_Recv(&tmpEnqueueUnmapMemObject, sizeof(tmpEnqueueUnmapMemObject), MPI_BYTE, 0,
> 			 ENQ_UNMAP_MEMOBJ_FUNC, slaveComm, &status);
> 	if (event != NULL)
> 	{
> 		*event = tmpEnqueueUnmapMemObject.event;
> 	}
> 
> 	return tmpEnqueueUnmapMemObject.res;
> }
> 
