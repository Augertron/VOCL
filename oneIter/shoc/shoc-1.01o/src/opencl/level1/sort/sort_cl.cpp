const char *cl_source_sort =
"// This kernel code based in part on CUDPP.  Please see the notice in\n"
"// LICENSE_CUDPP.txt.\n"
"\n"
"inline uint scanLSB(const uint val, __local uint* s_data)\n"
"{\n"
"    // Local mem is 256 uints long, set first half to 0\n"
"    int idx = get_local_id(0);\n"
"    s_data[idx] = 0;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Set 2nd half to thread local sum (sum of the 4 elems from global mem)\n"
"    idx += get_local_size(0); // += 128 in this case\n"
"\n"
"    // Unrolled scan in local memory\n"
"    uint t;\n"
"    s_data[idx] = val;     barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx -  1];  barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx -  2];  barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx -  4];  barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx -  8];  barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx - 16];  barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx - 32];  barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx - 64];  barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    return s_data[idx] - val;  // convert inclusive -> exclusive\n"
"}\n"
"\n"
"inline uint4 scan4(uint4 idata, __local uint* ptr)\n"
"{\n"
"    uint4 val4 = idata;\n"
"    uint4 sum;\n"
"\n"
"    // Scan the 4 elements in idata within this thread\n"
"    sum.x = val4.x;\n"
"    sum.y = val4.y + sum.x;\n"
"    sum.z = val4.z + sum.y;\n"
"    uint val = val4.w + sum.z;\n"
"\n"
"    // Now scan those sums across the local work group\n"
"    val = scanLSB(val, ptr);\n"
"\n"
"    val4.x = val;\n"
"    val4.y = val + sum.x;\n"
"    val4.z = val + sum.y;\n"
"    val4.w = val + sum.z;\n"
"\n"
"    return val4;\n"
"}\n"
"\n"
"//----------------------------------------------------------------------------\n"
"//\n"
"// radixSortBlocks sorts all blocks of data independently in shared\n"
"// memory.  Each thread block (CTA) sorts one block of 4*CTA_SIZE elements\n"
"//\n"
"// The radix sort is done in two stages.  This stage calls radixSortBlock\n"
"// on each block independently, sorting on the basis of bits\n"
"// (startbit) -> (startbit + nbits)\n"
"//----------------------------------------------------------------------------\n"
"\n"
"__kernel void radixSortBlocks(uint nbits, uint startbit,\n"
"                              __global uint4* keysOut,\n"
"                              __global uint4* valuesOut,\n"
"                              __global uint4* keysIn,\n"
"                              __global uint4* valuesIn,\n"
"                              __local uint* sMem)\n"
"{\n"
"    // Get Indexing information\n"
"    uint i = get_global_id(0);\n"
"    uint tid = get_local_id(0);\n"
"    uint localSize = get_local_size(0);\n"
"\n"
"    // Load keys and vals from global memory\n"
"    uint4 key, value;\n"
"    key = keysIn[i];\n"
"    value = valuesIn[i];\n"
"\n"
"    // For each of the 4 bits\n"
"    for(uint shift = startbit; shift < (startbit + nbits); ++shift)\n"
"    {\n"
"        // Check if the LSB is 0\n"
"        uint4 lsb;\n"
"        lsb.x = !((key.x >> shift) & 0x1);\n"
"        lsb.y = !((key.y >> shift) & 0x1);\n"
"        lsb.z = !((key.z >> shift) & 0x1);\n"
"        lsb.w = !((key.w >> shift) & 0x1);\n"
"        \n"
"        // Do an exclusive scan of how many elems have 0's in the LSB\n"
"        // When this is finished, address.n will contain the number of\n"
"        // elems with 0 in the LSB which precede elem n\n"
"        uint4 address = scan4(lsb, sMem);\n"
"\n"
"        __local uint numtrue[1];\n"
"\n"
"        // Store the total number of elems with an LSB of 0\n"
"        // to shared mem\n"
"        if (tid == localSize - 1)\n"
"        {\n"
"            numtrue[0] = address.w + lsb.w;\n"
"        }\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        // Determine rank -- position in the block\n"
"        // If your LSB is 0 --> your position is the scan of 0's\n"
"        // If your LSB is 1 --> your position is calculated as below\n"
"        uint4 rank;\n"
"        int idx = tid*4;\n"
"        rank.x = lsb.x ? address.x : numtrue[0] + idx     - address.x;\n"
"        rank.y = lsb.y ? address.y : numtrue[0] + idx + 1 - address.y;\n"
"        rank.z = lsb.z ? address.z : numtrue[0] + idx + 2 - address.z;\n"
"        rank.w = lsb.w ? address.w : numtrue[0] + idx + 3 - address.w;\n"
"\n"
"        // Scatter keys into local mem\n"
"        sMem[(rank.x & 3) * localSize + (rank.x >> 2)] = key.x;\n"
"        sMem[(rank.y & 3) * localSize + (rank.y >> 2)] = key.y;\n"
"        sMem[(rank.z & 3) * localSize + (rank.z >> 2)] = key.z;\n"
"        sMem[(rank.w & 3) * localSize + (rank.w >> 2)] = key.w;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        // Read keys out of local mem into registers, in prep for\n"
"        // write out to global mem\n"
"        key.x = sMem[tid];\n"
"        key.y = sMem[tid +     localSize];\n"
"        key.z = sMem[tid + 2 * localSize];\n"
"        key.w = sMem[tid + 3 * localSize];\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        // Scatter values into local mem\n"
"        sMem[(rank.x & 3) * localSize + (rank.x >> 2)] = value.x;\n"
"        sMem[(rank.y & 3) * localSize + (rank.y >> 2)] = value.y;\n"
"        sMem[(rank.z & 3) * localSize + (rank.z >> 2)] = value.z;\n"
"        sMem[(rank.w & 3) * localSize + (rank.w >> 2)] = value.w;\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"        // Read keys out of local mem into registers, in prep for\n"
"        // write out to global mem\n"
"        value.x = sMem[tid];\n"
"        value.y = sMem[tid +     localSize];\n"
"        value.z = sMem[tid + 2 * localSize];\n"
"        value.w = sMem[tid + 3 * localSize];\n"
"        barrier(CLK_LOCAL_MEM_FENCE);\n"
"    }\n"
"    keysOut[i]   = key;\n"
"    valuesOut[i] = value;\n"
"}\n"
"\n"
"//----------------------------------------------------------------------------\n"
"// Given an array with blocks sorted according to a 4-bit radix group, each\n"
"// block counts the number of keys that fall into each radix in the group, and\n"
"// finds the starting offset of each radix in the block.  It then writes the\n"
"// radix counts to the counters array, and the starting offsets to the\n"
"// blockOffsets array.\n"
"//----------------------------------------------------------------------------\n"
"\n"
"__kernel void findRadixOffsets(__global uint2* keys,\n"
"                               __global uint* counters,\n"
"                               __global uint* blockOffsets,\n"
"                               uint startbit,\n"
"                               uint numElements,\n"
"                               uint totalBlocks,\n"
"                               __local uint* sRadix1)\n"
"{\n"
"    __local uint  sStartPointers[16];\n"
"    uint groupId = get_group_id(0);\n"
"    uint localId = get_local_id(0);\n"
"    uint groupSize = get_local_size(0);\n"
"\n"
"    // Load two keys in from global memory\n"
"    uint2 radix2;\n"
"    radix2 = keys[get_global_id(0)];\n"
"\n"
"    // Convert those keys to their 4-bit radix\n"
"    sRadix1[2 * localId]     = (radix2.x >> startbit) & 0xF;\n"
"    sRadix1[2 * localId + 1] = (radix2.y >> startbit) & 0xF;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Finds the position where the sRadix1 entries differ and stores start\n"
"    // index for each radix.\n"
"    if (localId < 16)\n"
"    {\n"
"        sStartPointers[localId] = 0;\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // If this threads radix is different from the previous thread,\n"
"    // it has an index where the radix changes, write to shared mem\n"
"    if ((localId > 0) && (sRadix1[localId] != sRadix1[localId - 1]) )\n"
"    {\n"
"        sStartPointers[sRadix1[localId]] = localId;\n"
"    }\n"
"    // Same thing, but on second half of elements\n"
"    if (sRadix1[localId + groupSize] != sRadix1[localId + groupSize - 1])\n"
"    {\n"
"        sStartPointers[sRadix1[localId + groupSize]] = localId + groupSize;\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    if (localId < 16)\n"
"    {\n"
"        blockOffsets[groupId*16 + localId] = sStartPointers[localId];\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // Compute the number of elems with each radix\n"
"    if ((localId > 0) && (sRadix1[localId] != sRadix1[localId - 1]) )\n"
"    {\n"
"        sStartPointers[sRadix1[localId - 1]] =\n"
"            localId - sStartPointers[sRadix1[localId - 1]];\n"
"    }\n"
"    if (sRadix1[localId + groupSize] != sRadix1[localId + groupSize - 1] )\n"
"    {\n"
"        sStartPointers[sRadix1[localId + groupSize - 1]] =\n"
"            localId + groupSize - sStartPointers[sRadix1[localId+groupSize-1]];\n"
"    }\n"
"\n"
"    if (localId == groupSize - 1)\n"
"    {\n"
"        sStartPointers[sRadix1[2 * groupSize - 1]] =\n"
"            2 * groupSize - sStartPointers[sRadix1[2 * groupSize - 1]];\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    if(localId < 16)\n"
"    {\n"
"        counters[localId * totalBlocks + groupId] = sStartPointers[localId];\n"
"    }\n"
"}\n"
"//----------------------------------------------------------------------------\n"
"// reorderData shuffles data in the array globally after the radix offsets\n"
"// have been found. On compute version 1.1 and earlier GPUs, this code depends\n"
"// on RadixSort::CTA_SIZE being 16 * number of radices (i.e. 16 * 2^nbits).\n"
"//----------------------------------------------------------------------------\n"
"__kernel void reorderData(uint  startbit,\n"
"                          __global uint  *outKeys,\n"
"                          __global uint  *outValues,\n"
"                          __global uint2 *keys,\n"
"                          __global uint2 *values,\n"
"                          __global uint  *blockOffsets,\n"
"                          __global uint  *offsets,\n"
"                          __global uint  *sizes,\n"
"                          uint   totalBlocks)\n"
"{\n"
"    __local uint2 sKeys2[256];\n"
"    __local uint2 sValues2[256];\n"
"    __local uint  sOffsets[16];\n"
"    __local uint  sBlockOffsets[16];\n"
"    __local uint* sKeys1   = (__local uint*) sKeys2;\n"
"    __local uint* sValues1 = (__local uint*) sValues2;\n"
"    uint groupSize = get_local_size(0);\n"
"    uint blockId = get_group_id(0);\n"
"\n"
"    uint i = blockId * get_local_size(0) + get_local_id(0);\n"
"\n"
"    sKeys2[get_local_id(0)]   = keys[i];\n"
"    sValues2[get_local_id(0)] = values[i];\n"
"\n"
"    if(get_local_id(0) < 16)\n"
"    {\n"
"        sOffsets[get_local_id(0)]      = offsets[get_local_id(0) * totalBlocks\n"
"                                                 + blockId];\n"
"        sBlockOffsets[get_local_id(0)] = blockOffsets[blockId * 16 +\n"
"                                                      get_local_id(0)];\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    uint radix = (sKeys1[get_local_id(0)] >> startbit) & 0xF;\n"
"    uint globalOffset = sOffsets[radix] + get_local_id(0) -\n"
"            sBlockOffsets[radix];\n"
"\n"
"    outKeys[globalOffset]   = sKeys1[get_local_id(0)];\n"
"    outValues[globalOffset] = sValues1[get_local_id(0)];\n"
"\n"
"    radix = (sKeys1[get_local_id(0) + groupSize] >> startbit) & 0xF;\n"
"    globalOffset = sOffsets[radix] + get_local_id(0) + groupSize -\n"
"            sBlockOffsets[radix];\n"
"\n"
"    outKeys[globalOffset]   = sKeys1[get_local_id(0) + groupSize];\n"
"    outValues[globalOffset] = sValues1[get_local_id(0) + groupSize];\n"
"}\n"
"\n"
"// Scan Kernels\n"
"// Duplicated here because Sort uses uints and OpenCL doesn't\n"
"// support templates yet\n"
"\n"
"__kernel void\n"
"addUniform(__global uint *d_vector, __global const uint *d_uniforms,\n"
"           const int n)\n"
"{\n"
"    __local uint uni[1];\n"
"\n"
"    if (get_local_id(0) == 0)\n"
"    {\n"
"        uni[0] = d_uniforms[get_group_id(0)];\n"
"    }\n"
"\n"
"    unsigned int address = get_local_id(0) + (get_group_id(0) *\n"
"            get_local_size(0) * 4);\n"
"\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // 4 elems per thread\n"
"    for (int i = 0; i < 4 && address < n; i++)\n"
"    {\n"
"        d_vector[address] += uni[0];\n"
"        address += get_local_size(0);\n"
"    }\n"
"}\n"
"\n"
"inline uint scanLocalMem(const uint val, __local uint* s_data)\n"
"{\n"
"    // Shared mem is 512 uints long, set first half to 0\n"
"    int idx = get_local_id(0);\n"
"    s_data[idx] = 0.0f;\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"    \n"
"    // Set 2nd half to thread local sum (sum of the 4 elems from global mem)\n"
"    idx += get_local_size(0); // += 256\n"
"    \n"
"    uint t;\n"
"    s_data[idx] = val;     barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx -  1];  barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx -  2];  barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx -  4];  barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx -  8];  barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx - 16];  barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx - 32];  barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx - 64];  barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"    t = s_data[idx - 128]; barrier(CLK_LOCAL_MEM_FENCE);\n"
"    s_data[idx] += t;      barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    return s_data[idx-1];\n"
"}\n"
"\n"
"__kernel void scan(__global uint *g_odata, __global uint *g_idata,\n"
"        __global uint *g_blockSums, const int n, const int fullBlock,\n"
"        const int storeSum)\n"
"{\n"
"    __local uint s_data[512];\n"
"\n"
"    // Load data into shared mem\n"
"    uint4 tempData;\n"
"    uint4 threadScanT;\n"
"    uint res;\n"
"    __global uint4* inData  = (__global uint4*) g_idata;\n"
"\n"
"    const int gid = get_global_id(0);\n"
"    const int tid = get_local_id(0);\n"
"    const int i = gid * 4;\n"
"\n"
"    // If possible, read from global mem in a uint4 chunk\n"
"    if (fullBlock || i + 3 < n)\n"
"    {\n"
"        // scan the 4 elems read in from global\n"
"        tempData       = inData[gid];\n"
"        threadScanT.x = tempData.x;\n"
"        threadScanT.y = tempData.y + threadScanT.x;\n"
"        threadScanT.z = tempData.z + threadScanT.y;\n"
"        threadScanT.w = tempData.w + threadScanT.z;\n"
"        res = threadScanT.w;\n"
"    }\n"
"    else\n"
"    {   // if not, read individual uints, scan & store in lmem\n"
"        threadScanT.x = (i < n) ? g_idata[i] : 0.0f;\n"
"        threadScanT.y = ((i+1 < n) ? g_idata[i+1] : 0.0f) + threadScanT.x;\n"
"        threadScanT.z = ((i+2 < n) ? g_idata[i+2] : 0.0f) + threadScanT.y;\n"
"        threadScanT.w = ((i+3 < n) ? g_idata[i+3] : 0.0f) + threadScanT.z;\n"
"        res = threadScanT.w;\n"
"    }\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    res = scanLocalMem(res, s_data);\n"
"    barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"    // If we have to store the sum for the block, have the last work item \n"
"    // in the block write it out\n"
"    if (storeSum && tid == get_local_size(0)-1) {\n"
"        g_blockSums[get_group_id(0)] = res + threadScanT.w;\n"
"    }\n"
"\n"
"    // write results to global memory\n"
"    __global uint4* outData = (__global uint4*) g_odata;\n"
"     \n"
"    tempData.x = res;\n"
"    tempData.y = res + threadScanT.x;\n"
"    tempData.z = res + threadScanT.y;\n"
"    tempData.w = res + threadScanT.z;\n"
"\n"
"    if (fullBlock || i + 3 < n)\n"
"    {\n"
"        outData[gid] = tempData;\n"
"    }\n"
"    else\n"
"    {\n"
"        if ( i    < n) { g_odata[i]   = tempData.x;\n"
"        if ((i+1) < n) { g_odata[i+1] = tempData.y;\n"
"        if ((i+2) < n) { g_odata[i+2] = tempData.z; } } }\n"
"    }\n"
"}\n"
;
